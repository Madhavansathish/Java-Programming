# Using Built in function
class Solution {
    public int mySqrt(int x) {
        double sqrt=Math.sqrt(x);
        int num=(int)sqrt;
        return num;
    }
}


# Not an optimized approach
class Solution {
    public int mySqrt(int x) {

        // Start checking from 1 (smallest possible square root)
        long i = 1;

        // Keep increasing i while i*i is less than or equal to x
        // This finds the point where i becomes too large
        while (i * i <= x) {
            i++;
        }

        // When loop stops, i*i is greater than x
        // So (i - 1) is the largest number whose square is <= x
        // This gives the integer (floor) square root
        return (int) i - 1;
    }
}

# optimized solution
class Solution {
    public int mySqrt(int x) {

        // If x is 0, its square root is also 0
        if (x == 0) return 0;

        // Binary search range: possible square roots lie between 0 and x
        int l = 0, r = x;

        // This will store the best possible answer (floor value of sqrt)
        int ans = 0;

        // Continue searching while the range is valid
        while (l <= r) {

            // Find the middle value safely (avoids overflow)
            int mid = l + (r - l) / 2;

            // Check if mid * mid is less than or equal to x
            // Cast to long to avoid integer overflow
            if ((long) mid * mid <= x) {

                // mid is a valid square root candidate
                ans = mid;

                // Try to find a bigger valid square root
                l = mid + 1;

            } else {
                // mid * mid is greater than x
                // So discard the right half
                r = mid - 1;
            }
        }

        // ans contains the integer (floor) square root of x
        return ans;
    }
}

